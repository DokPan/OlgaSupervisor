import pandas as pd
import re
from typing import Dict, List
import os

class ScriptGenerator:
    
    def __init__(self):
        self._scripts_generated = False
    
    def generate_scripts_from_errors(self, errors_df: pd.DataFrame):
        if self._scripts_generated:
            print("Скрипты уже были сгенерированы ранее")
            return False
            
        print("Генерация решений для исправления ошибок...")
        
        if len(errors_df) == 0:
            print("Нет ошибок для генерации решений")
            return False
        
        category_stats = errors_df['Категория ошибки'].value_counts()
        
        solutions = self._generate_category_solutions(category_stats, errors_df)
        
        self._save_solutions_to_file(solutions, len(errors_df))
        
        print("Конкретные решения для исправления сгенерированы!")
        self._scripts_generated = True
        return True

    def _generate_category_solutions(self, category_stats, errors_df) -> List[Dict]:
        
        solutions = []
        
        for category, count in category_stats.items():
            examples = self._get_category_examples(errors_df, category)
            
            solution = self._create_category_solution(category, count, examples)
            solutions.append(solution)
        
        return solutions

    def _get_category_examples(self, errors_df, category, max_examples=2):
        category_errors = errors_df[errors_df['Категория ошибки'] == category]
        examples = []
        
        for _, row in category_errors.head(max_examples).iterrows():
            transcript = str(row['call_transcript'])
            excerpt = self._extract_dialog_excerpt(transcript)
            if excerpt:
                examples.append(excerpt)
        
        return examples

    def _extract_dialog_excerpt(self, transcript: str) -> str:
        lines = [line.strip() for line in transcript.split(';') if line.strip()]
        if len(lines) >= 2:
            return '\n'.join(lines[-2:])
        return transcript[:200] + '...' if len(transcript) > 200 else transcript

    def _create_category_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        if category == 'Серьезные проблемы коммуникации':
            return self._create_communication_solution(category, count, examples)
        elif category == 'Клиент отказывается, но статус не отток':
            return self._create_false_negative_solution(category, count, examples)
        elif category == 'Ложный отток (клиент соглашается)':
            return self._create_false_positive_solution(category, count, examples)
        elif category == 'Неопределенность при оттоке':
            return self._create_uncertainty_solution(category, count, examples)
        elif category == 'Игнорирование критических вопросов':
            return self._create_ignored_questions_solution(category, count, examples)
        elif category == 'Неправильный собеседник':
            return self._create_wrong_person_solution(category, count, examples)
        else:
            return self._create_general_solution(category, count, examples)

    def _create_communication_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
    РЕШЕНИЕ ДЛЯ: {category}
    Обнаружено случаев: {count}

    ПРОБЛЕМА: Критические проблемы с пониманием и связью

    ЧТО ДЕЛАТЬ:

    1. ВНЕДРИТЬ СИСТЕМУ ЭСКАЛАЦИИ ПРИ ПРОБЛЕМАХ СВЯЗИ
    - При плохой слышимости после 2 попыток предлагать альтернативный канал
    - Добавить фразу: "Вас плохо слышно, можем продолжить в онлайн-чате"
    - При множественных проблемах с пониманием завершать диалог

    2. СОКРАТИТЬ ДИАЛОГ ПРИ ТЕХНИЧЕСКИХ ПРОБЛЕМАХ
    - При проблемах со связью переходить сразу к ключевому вопросу
    - Не продолжать диалог при устойчивых помехах
    - Вежливо завершать: "Извините, проблемы со связью, перезвоним позже"

    3. ДОБАВИТЬ ДЕТЕКЦИЮ КАЧЕСТВА АУДИО
    - Мониторить количество проблем с пониманием
    - Автоматически определять повторяющиеся вопросы
    - Прекращать диалог при критическом уровне непонимания

    ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
    - Эффективное завершение проблемных диалогов
    - Снижение времени на бесполезные разговоры
    - Улучшение клиентского опыта
    """
        return {'category': category, 'solution': solution.strip()}

    def _create_false_negative_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Клиент отказывается от услуг, но система не распознает это как отток

ЧТО ДЕЛАТЬ:

1. УЛУЧШИТЬ РАСПОЗНАВАНИЕ ОТРИЦАТЕЛЬНЫХ ОТВЕТОВ
   - Добавить анализ различных формулировок отказа
   - Учитывать не только прямые "нет", но и косвенные отказы
   - Распознавать жалобы на стоимость как сигнал оттока

2. ДОБАВИТЬ КОНТРОЛЬНЫЕ ВОПРОСЫ ПРИ ПРИЗНАКАХ ОТКАЗА
   - При негативных высказываниях уточнять намерения
   - Использовать вопрос: "Значит ли это, что вы отказываетесь от сотрудничества?"
   - Подтверждать отказ перед сменой статуса

3. ВНЕДРИТЬ ПРОВЕРКУ СОГЛАСОВАННОСТИ ОТВЕТА И СТАТУСА
   - Сравнивать ответ клиента с проставленным статусом
   - При явном отказе автоматически менять статус на отток
   - Добавить валидацию перед фиксацией статуса

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Своевременное выявление реального оттока
- Более точная классификация намерений клиента
- Возможность предложить альтернативы уходящим клиентам
"""
        return {'category': category, 'solution': solution.strip()}

    def _create_false_positive_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Клиент соглашается продолжать сотрудничество, но система помечает как отток

ЧТО ДЕЛАТЬ:

1. УЛУЧШИТЬ РАСПОЗНАВАНИЕ ПОЛОЖИТЕЛЬНЫХ ОТВЕТОВ
   - Расширить словарь утвердительных формулировок
   - Анализировать контекст ответа, а не только ключевые слова
   - Учитывать уверенность и определенность ответа

2. ДОБАВИТЬ УТОЧНЯЮЩИЕ ВОПРОСЫ ПРИ НЕОДНОЗНАЧНОСТИ
   - При сомнительных ответах переспрашивать о намерениях
   - Использовать вопрос: "Уточните, планируете ли продолжать сотрудничество?"
   - Подтверждать согласие перед сменой статуса

3. ВНЕДРИТЬ ПРОВЕРКУ ПРОТИВОРЕЧИЙ СТАТУСА
   - Сравнивать ответ клиента с проставленным статусом оттока
   - При явном согласии автоматически менять статус
   - Добавить систему коррекции ошибочных статусов

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Снижение ложных срабатываний оттока
- Более точное определение лояльных клиентов
- Улучшение качества данных для аналитики
"""
        return {'category': category, 'solution': solution.strip()}

    def _create_uncertainty_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Клиент выражает сомнения или неопределенность, но система проставляет финальный статус

ЧТО ДЕЛАТЬ:

1. ДОБАВИТЬ ОБРАБОТКУ НЕОПРЕДЕЛЕННЫХ ОТВЕТОВ
   - Распознавать выражения сомнений и неуверенности
   - Не ставить финальный статус при неопределенности
   - Использовать промежуточный статус "Требует уточнения"

2. ВНЕДРИТЬ СЕРИЮ УТОЧНЯЮЩИХ ВОПРОСОВ
   - Помогать клиенту прояснить свою позицию
   - Использовать вопросы: "Что именно вызывает сомнения?", "Какая информация нужна для решения?"
   - Предлагать время на размышление при необходимости

3. ДОБАВИТЬ ОТЛОЖЕННУЮ КЛАССИФИКАЦИЮ
   - Не фиксировать окончательный статус до получения четкого ответа
   - Предлагать повторный контакт через 1-2 дня
   - Использовать статус "Отложенное решение"

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Более точное определение реальных намерений
- Снижение ошибок из-за преждевременной классификации
- Улучшение взаимодействия с неопределившимися клиентами
"""
        return {'category': category, 'solution': solution.strip()}

    def _create_ignored_questions_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Робот не отвечает на важные вопросы клиента, продолжая стандартный сценарий

ЧТО ДЕЛАТЬ:

1. ДОБАВИТЬ ПРИОРИТЕТНУЮ ОБРАБОТКУ ВОПРОСОВ
   - Сначала отвечать на запросы клиента, потом продолжать диалог
   - Использовать шаблон: "Отвечаю на ваш вопрос, затем задам свой"
   - Прерывать стандартный сценарий при поступлении вопроса

2. СОЗДАТЬ БАЗУ ОТВЕТОВ НА ЧАСТЫЕ ВОПРОСЫ
   - Иметь готовые ответы на стандартные запросы о договорах и условиях
   - Использовать шаблоны: "По вашему договору могу сообщить...", "Условия обслуживания..."
   - Обучить модель распознаванию типовых вопросов

3. ВНЕДРИТЬ ПРОВЕРКУ ОТВЕТОВ НА ВОПРОСЫ
   - Убеждаться, что вопрос клиента получил ответ
   - Использовать подтверждение: "Я ответил на ваш вопрос?"
   - Только после ответа продолжать основной сценарий

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Полное удовлетворение информационных потребностей клиента
- Снижение раздражения от игнорирования вопросов
- Улучшение качества сервиса и доверия клиентов
"""
        return {'category': category, 'solution': solution.strip()}

    def _create_wrong_person_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Диалог продолжается с лицом, которое не принимает решений по корпоративному обслуживанию

ЧТО ДЕЛАТЬ:

1. ДОБАВИТЬ ВЕРИФИКАЦИЮ В НАЧАЛЕ ДИАЛОГА
   - Задавать вопрос об ответственности в первых репликах
   - Использовать фразу: "Вы являетесь ответственным за услуги связи?"
   - Подтверждать правильность собеседника перед продолжением

2. РАСПОЗНАВАТЬ УКАЗАНИЯ НА НЕПРАВИЛЬНОГО СОБЕСЕДНИКА
   - Детектировать фразы об ошибке в определении ответственного
   - Реагировать на указания: "не тот человек", "ошиблись номером"
   - Немедленно прекращать диалог при таких признаках

3. ЗАПРАШИВАТЬ КОНТАКТЫ ОТВЕТСТВЕННОГО ЛИЦА
   - При отрицании ответственности вежливо завершать разговор
   - Просить контакты нужного сотрудника
   - Использовать фразу: "Можете подсказать, с кем лучше обсудить этот вопрос?"

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Прекращение непродуктивных диалогов
- Получение контактов реальных ЛПР
- Экономия времени и ресурсов оператора
"""
        return {'category': category, 'solution': solution.strip()}

    def _create_general_solution(self, category: str, count: int, examples: List[str]) -> Dict:
        
        solution = f"""
РЕШЕНИЕ ДЛЯ: {category}
Обнаружено случаев: {count}

ПРОБЛЕМА: Требуется анализ конкретных случаев для определения паттерна ошибки

ЧТО ДЕЛАТЬ:

1. ПРОВЕСТИ ДЕТАЛЬНЫЙ АНАЛИЗ ОШИБОК
   - Изучить транскрипты для выявления общего паттерна
   - Сгруппировать похожие случаи для выявления тенденций
   - Определить корневые причины ошибок классификации

2. РАЗРАБОТАТЬ СПЕЦИФИЧНЫЕ ПРАВИЛА ОБРАБОТКИ
   - Создать целевые решения для выявленного паттерна
   - Протестировать новые правила на исторических данных
   - Внедрить мониторинг эффективности исправлений

3. ОБНОВИТЬ ЛОГИКУ КЛАССИФИКАЦИИ
   - Добавить новые правила в систему принятия решений
   - Обучить модель на исправленных данных
   - Постоянно совершенствовать алгоритмы распознавания

ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
- Устранение конкретного типа ошибок классификации
- Улучшение общей точности системы
- Накопление опыта для будущих улучшений
"""
        return {'category': category, 'solution': solution.strip()}

    def _save_solutions_to_file(self, solutions: List[Dict], total_errors: int):
        try:
            solutions_file = "output/category_correction_solutions.txt"
            
            with open(solutions_file, 'w', encoding='utf-8') as f:
                f.write("КОНКРЕТНЫЕ РЕШЕНИЕ ДЛЯ ИСПРАВЛЕНИЯ ОШИБОК\n")
                f.write("=" * 60 + "\n")
                f.write(f"Всего обнаружено ошибок: {total_errors}\n\n")
                
                for solution_data in solutions:
                    f.write(solution_data['solution'])
                    f.write("\n" + "=" * 60 + "\n\n")
            
            print(f"Решения сохранены: {solutions_file}")
            print(f"Охвачено {len(solutions)} категорий ошибок")
            
        except Exception as e:
            print(f"Ошибка сохранения решений: {e}")